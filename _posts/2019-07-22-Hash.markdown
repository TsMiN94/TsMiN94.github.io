---
title: "Hash"
layout: post
date: 2019-07-22 22:30
tag: Hash
projects: true
hidden: true # don't count this post in blog pagination
description: "None"
category: project
author: TaeSeongMin
externalLink: false
---


#### Hash란?
<ul>
●해시란 임의길이의 데이터를 고정된 데이터의 크기로 변환하는 것을 말한다. 변환된 데이터를 우리는 해시코드, 해시섬으로 말할 수 있다.
    해시코드를 사용함으로써 특정 배열의 인덱스를 찾거나 그 배열안에 있는 값을 얻어낼 수 있다. 해시를 이용하면 특정 데이터에 대한 값을 바로 찾아 낼 수 있기 때문에 빠른 속도로 일을 처리할 수 있다.




#### Hash Function
<ul>
● HashCode는 데이터에 대한 고유한 정숫값을 말한다. 객체를 비교할 때 우리는 equals()를 사용하여 객체를 비교하는데 이 때 HashCode를
보고 비교하게 된다. 그렇지만 String 클래스에서는 조금 다르다. HashCode는 객체마다 고유한 정숫값을 가지고 있다고 했지만 실제로
<br><br>
<pre>
String a = "Java";
String b= new String("Java");
<br>
//a, b 객체는 서로다른 객체이므로 고유한 정숫값을 가져야하는게 맞지만 실제 해쉬코드 값은 같은 값을 보여주게 된다.

a.hashCode() = 3254818
b.hashCode() = 3254818
</pre>
</ul>
<ul>
    이러한 이유는 String 클래스에 제공하는 hashCode()의 구현이 실제로 Object클래스의 hashCode()와는 다르게 재정의 하여 구현이 되어 있기 때문이       다. 또한 다른 객체라 하더라도 hashCode값은 동일할 수 있는데 이렇기에 우리는 equals를 통해 false값이 나오더라도 hashCode의 값이 꼭 다를 필요     가 없다는것을 알아야한다.<br><br>
</ul>

<br>

#### Collusion (충돌)
<ul>
●Hash 함수를 통해서 얻어낸 해시코드의 값을 사용하여 HashTable을 만들어 값을 저장하는경우 같은 해시코드값에 대하여 충돌이 일어날 수 가 있다. 키값이 다르더라도 해시코드가 같은 값을 주는 경우가 있다. 그렇기에 우리는 최소한의 충돌을 해결하며 일을 처리해야 한다.

<pre>
 int index = hashCode("key") % M ;
</pre>

index는 같은 값이 나올 수 있게되고 이러한 문제는 Open Adressing , Seperate Chaining의 기법으로 해결할 수 있다.<br>
 *Open Addressing 이란 같은 index가 나왔을경우 그 다음 index에 저장하는 방식이다. 이러한 방법은 데이터가 적을 경우 효율적이다. 데이터가 많게 되면 캐쉬 적중률 (hit ratio)가 낮아지기 때문이다. 또한 데이터가 많으면 삭제를 할경우 처리하기가 까다롭기 때문에 데이터가 적은 경우 사용한것이 적절한 방법이다. <br>
 *Seperate Chaining 이란 인덱스가 겹칠경우 해당 연결리스트를 이용하여 노드를 하나 더 만들어 인덱스가 다음 포인터의 주소값을 가지게 됨으로써 index가 겹치는 문제를 해결할 수 있다. 또한 삭제할 경우 그 처리가 간단하다는 점이 있다. 그러나 이 방법 역시도 하나의 인덱스에 데이터가 밀집 될 경우가 있어 그경우에는 트리로 구현하는 것이 더 좋다고 한다.
 <br>
<hr/>

